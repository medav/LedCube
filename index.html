<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Led Cube Project by medav</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Led Cube Project</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/medav/ledcube" class="btn">View on GitHub</a>
      <a href="https://github.com/medav/ledcube/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/medav/ledcube/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="8x8x8-led-cube-project" class="anchor" href="#8x8x8-led-cube-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>8x8x8 LED Cube Project</h2>

<p><img src="https://2zqp8w-bn1305.files.1drv.com/y3m0Dv7Xa0R_Emk-VhlvV3d_oqgr06IRckKShxmcvy-5cK9KZv2-AtmFuGf40tb-o4o5vUDHKkVBho87KozqJ5Eh3sWjWsyhAte0i68YKBQnsID2_w5OuTVMTFLePjAUKcqhzOB9P1b89nKejfLc39lM_O51MCEBoFoNfoX_PnJStI?width=1024&amp;height=680&amp;cropmode=none" alt="Cover Image">
<em>The finished Cube hooked up to a programmer and oscilliscope</em></p>

<p>Over the last year and a half, I designed, constructed and programmed an 8x8x8 LED Cube. This page serves as a complete description of my design and how I was able to make it all work. The goal of this page is to provide enough information so that a beginner in hardware and software could build their own cube. </p>

<p>If you're interested in seeing more images before reading on, take a look at the <a href="http://1drv.ms/1XGtxvg">gallery</a>.</p>

<p>Ready to get started? Read on!</p>

<hr>

<h2>
<a id="materials" class="anchor" href="#materials" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Materials</h2>

<ul>
<li>512 x 5mm diffused LEDs (Any color) </li>
<li>4 x TLC59116 Constant current sink LED drivers </li>
<li>1 x PIC18LF45K22 MCU</li>
<li>8 x 2n4401 NPN type transistors</li>
<li>8 x FQD11P06 P-Channel MOSFETs</li>
<li>1 x LM350 voltage regulator</li>
<li>Breadboards to put it on</li>
</ul>

<hr>

<h2>
<a id="high-level-design" class="anchor" href="#high-level-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>High Level Design</h2>

<p><img src="https://bvtfsq-bn1305.files.1drv.com/y3m6SXNtfDGpxcCuLSCWiu8hR_I4eLB3B9x1GpAqS_q12BVjnfx0_Eifj3n6QOH6j0N9ueSNTJjgWB1yYSUjNJxoEjOnsKKaPv7G_-c3hylnCgbuiOhDJ8sBi0RppzKhmETSgaQ-krd7_TtyVTTcRfcvbRTdBcbGInjcUXmhMpJcNQ?width=1024&amp;height=662&amp;cropmode=none" alt="Cube Schematic">
<em>Schematic of the cube (Power lines not shown)</em></p>

<p>The overall design is works be performing a raster scan from the top down on a 3D array of LEDs. The array is designed such that each of 8 8x8 layers are addressed one at a time. 4 constant current display drivers capable of addressing 16 LEDs each. A PIC MCU is used to coordinate the refresh cycles by writing to the drivers appropriately. Finally, a Raspberry Pi is used as an interface and frame rendering system that is capable of communicating frames to the PIC.</p>

<h3>
<a id="512-led-array" class="anchor" href="#512-led-array" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>512 LED Array</h3>

<p>The whole array is broken into 8 layers of 64 LEDs Each. The cathodes of all the LEDs in a layer are soldered together allowing the whole layer to be powered at one time. The anodes of the LEDs form the columns of the array. Each layer then has 1 power input, and 64 addressable columns, allowing the driver to address 64 columns with the 4 display drivers.</p>

<h3>
<a id="display-drivers" class="anchor" href="#display-drivers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Display Drivers</h3>

<p>4 Texas Instruments TLC59116 16-bit I2C LED Sink Drivers are used to address a layer of 8x8 (64) LEDs. These drivers can read in data for one layer of LEDs and latch the output so that the layer can be displayed.</p>

<h3>
<a id="display-controller" class="anchor" href="#display-controller" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Display controller</h3>

<p>The display controller was a PIC18LF45K22 PIC Microcontroller programmed with a Mikro Electronika EasyProg. The driver was written in embedded C to act as a double buffered system capable of accepting asynchronous input through UART connection with a master controller while keeping the display refreshed.</p>

<h3>
<a id="raspberry-pi" class="anchor" href="#raspberry-pi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Raspberry Pi</h3>

<p>To give the cube the capability of almost anything, I used a Raspberry Pi as a master controller for the system. I run simple Raspian Linux on the Pi, and have developed a software API in Mono C# that abstracts away the underlying hardware interface and provides end users to easy address LEDs in a simple (x, y, z) format. The end result is a top level system that is capable of everything from simple animations to accepting network input and more!</p>

<hr>

<h2>
<a id="construction" class="anchor" href="#construction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Construction</h2>

<p>Constructing the cube was done in parts. The hardest is the array itself.</p>

<h3>
<a id="led-array" class="anchor" href="#led-array" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LED Array</h3>

<p>The array was built in layers of 8x8 LEDs. I found an old block of wood and used a drill press to place 5mm holes in a grid of 8x8, exactly 2cm (center to center) apart. I then placed the LEDs into the template and bent the cathodes down and soldered them together.</p>

<p><img src="https://bfuiva-bn1305.files.1drv.com/y3m5IwR9HmbWNapaksOPUAZqUnFSD8sD88ZX-i4P109g_KOkuC0Q0_4Qtz76dakMoIDR8Gayy0wg69jBMbYc9OncF643oBKE3Qzd8aI7oBGpOG-7y1UhDaTgU1prEem-y4lXwLXuQLhIRWmr6VNGWqf4w?width=1024&amp;height=579&amp;cropmode=none" alt="Block template">
<em>Block template and LED layers being soldered together</em></p>

<p>Each layer was made first, then they were put together. I used Lego parts as scaffolding to hold the layers in place while I soldered them.</p>

<p><img src="https://bfvt3w-bn1305.files.1drv.com/y3m3inepA4h2H0izW5T3mJEeWWbuRgA5gVzrLZG0U654f7t0FRHZgOiWkb26QYC8Sy77llMdn5sXuCmK0tgA12XI83gjiSEiLFWKX-BPCGOtzJo6dM_l1THb02m80rgBo6-CX2fxbXZkrOmrBFqWoXENA?width=807&amp;height=1024&amp;cropmode=none" alt="Finished Array">
<em>The finished array (Upside down, in the wood template)</em></p>

<h3>
<a id="display-drivers-1" class="anchor" href="#display-drivers-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Display Drivers</h3>

<p>I paired off the drivers and soldered them onto small breadboards.</p>

<p>Coming soon: Board schematics for the drivers.</p>

<h3>
<a id="layer-switches" class="anchor" href="#layer-switches" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Layer Switches</h3>

<p>The layer switches served as a way for the PIC's 3.3V logic to control a high current 12V line. Below is a diagram of the switches.</p>

<p><img src="https://bvtisq-bn1305.files.1drv.com/y3m2y_T8H6Q2uTNNXhNIzrf9KulXWN6ad0k53UnVj-M7YRBfa_vn2qOhEOik6aeoGAXnHqrJYCY6ctogLOnS1ZRpB83Oo2GhBvoaHdwcxbAjlrF1X-qoVagWLPyLjDiHlKkY2pNilS9uJ8eP1zPU5FIUsHxq-s25QBsMAhClIKa7co?width=623&amp;height=1018&amp;cropmode=none" alt="Layer switch diagram">
<em>Circuit diagram of switches (Note: only 4 are depicted here, there are 8 total).</em></p>

<p>The 8 input pins are connected to PORT B on the PIC. The PIC writes a single bit to the port to power on the layer.</p>

<p><img src="https://bvtjsq-bn1305.files.1drv.com/y3mAE36_-l6kzFkRiEVbW220uX3xGIhNKFyCvnB7Da9enbof_rdIcpNSz4OoVZ2svpYtHXv-06m0R8T_0mjdzBIb-vCSv1x-RHg_4-CvGs2OPGFNLRB-7Kl3_4dpQkN9ZyC2eXOUljKx8XGCNvBRZ3bxA?width=967&amp;height=1024&amp;cropmode=none" alt="Finished layer switches"></p>

<h3>
<a id="power-supply" class="anchor" href="#power-supply" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Power Supply</h3>

<p>This section isn't finished yet!</p>

<h3>
<a id="putting-it-together" class="anchor" href="#putting-it-together" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Putting it together</h3>

<p>Neither is this one!</p>

<hr>

<h2>
<a id="software" class="anchor" href="#software" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Software</h2>

<p>The software used to control the cube comes in to parts. The first is the embedded C code on the PIC. </p>

<h3>
<a id="display-controller-1" class="anchor" href="#display-controller-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Display Controller</h3>

<p>The code on the PIC acts as a double buffered display driver, allowing outside sources to pipe in frames over UART. It manages the drivers, taking care of setting up the correct internal register values, and also includes a auto-idle animation (I.e. a screen saver) and software configurable internal registers for directing the operation of the display cycle.</p>

<p>The files related to the PIC code are in ledcube/LedCubeMCU/. It is a MikroElektronika C for PIC project and can only be compiled and loaded as is with the MikroE compiler and programmer.</p>

<h3>
<a id="commandresponse-protocol-over-uart" class="anchor" href="#commandresponse-protocol-over-uart" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Command/Response Protocol over UART</h3>

<p>In the PIC code, in LedCubeMCUDriver.h, you will find the following lines,</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// Enum for commands</span>
<span class="pl-k">typedef</span> <span class="pl-k">enum</span> {
    NOOP,
    READFRAME = 0x91,
    SETCONTROL,
    IDLE,
    CLEAR = 0xEE,
    ENDCMD = 0xFF
} CUBECMD;</pre></div>

<p>These are arbitrarily defined, but my intent was that the usable commands would satisfy the following constraints:</p>

<ul>
<li>Of the pairs of bits in a byte, at least one bit in the left position is set (I.e. 0b10101010 &amp; CMD != 0x00). The reason is to not confuse commands with writing LED values, which are in the form of (0b01010101).</li>
<li>Should not be easy to mistakenly send over the line. Initially, when the Raspberry Pi boots, some garbage data can be sent over the UART accidentally (I.e. the line may drop to zero for an instant). This ensures that a READFRAME isn't started unless intended.</li>
</ul>

<p>The PIC command system acts as a state machine. Here is a quick diagram:
<img src="https://qfqopa-bn1305.files.1drv.com/y3m8afrfNmjBMfrH6HJBqYE95Ds7YAtARSovfkdWq_JgZT-1BVLTQDOwdFBf5e6bokI0ivNYg8nCrkBt759VT2r809zmrlSmN2309RrQCgmHSClL9nA1f6gJe3Gd6Apv1zbhuiFySwEapLU-FfI_8wV7puF3omnmoRvacAWCKJDxkE?width=1805&amp;height=1033&amp;cropmode=none" alt="Command FSM">
<em>State machine for command processing</em></p>

<p>The PIC will sit in IDLE until a byte is sent to it containing the command to start. If it is a READFRAME command, the PIC will enter the "Read to Buffer" state. This directs all further input to the back-buffer. Upon ENDCMD, the back-buffer will be swapped with the display buffer updating the frame instantly. For referance, a frame would be sent in the following format:</p>

<pre><code>READFRAME, &lt;FRAME PAYLOAD&gt;, ENDCMD
</code></pre>

<p>If you wanted to send a frame setting all LEDs ON, it looks like:</p>

<pre><code>9155...55FF
</code></pre>

<p>Where 0x55 is repeated 128 times.</p>

<p>Upon receiving any other command, the PIC will enter the "Read Args" state, which will read one byte at a time into an argument buffer until ENDCMD is received. A different buffer is used for this because the back-buffer is only for LED data and when swapped into the display, cannot contain any garbage from left over commands.</p>

<p>There is no error checking / correction done on the command system because throughput is important. As it stands, the interface is capable of about 66 FPS from the Pi to the display. Any sort of checking would only serve to add delay in reading a frame and reduce performance.</p>

<h3>
<a id="raspberry-pi-1" class="anchor" href="#raspberry-pi-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Raspberry Pi</h3>

<p>The code for the Raspberry Pi is actually quite simple. Now that we have the PIC set up to manage the display, we can pipe frames to it over the Pi's UART asynchronously. In PyLedCube/LedCubePy, there is a Python module which serves as an interface. It simply opens the Pi's UART (/dev/ttyAMA0), and converts (x, y, z) coordinates into their corresponding bits in the buffer. When WriteBuffer() is called, it dumps the frame to the PIC to be displayed. </p>

<p>Support for modifying the PIC's internal variables through SETCONTROL is not supported yet. In the future, it will be possible to modify existing and future variables on the PIC through the Python interface.</p>

<p>There also is a C# based interface written to work with Mono on the Pi. In the future I plan to evaluate using Windows 10 IoT core on the Pi, which would require this interface. </p>

<hr>

<h2>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h2>

<p>Michael Davies</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/medav/ledcube">Led Cube Project</a> is maintained by <a href="https://github.com/medav">medav</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
