{"name":"LED Cube Project","tagline":"","body":"## 8x8x8 LED Cube Project\r\n\r\n![Cover Image](https://2zqp8w-bn1305.files.1drv.com/y3m0Dv7Xa0R_Emk-VhlvV3d_oqgr06IRckKShxmcvy-5cK9KZv2-AtmFuGf40tb-o4o5vUDHKkVBho87KozqJ5Eh3sWjWsyhAte0i68YKBQnsID2_w5OuTVMTFLePjAUKcqhzOB9P1b89nKejfLc39lM_O51MCEBoFoNfoX_PnJStI?width=1024&height=680&cropmode=none)\r\n*The finished Cube hooked up to a programmer and oscilliscope*\r\n\r\nOver the last year and a half, I designed, constructed and programmed an 8x8x8 LED Cube. This page serves as a complete description of my design and how I was able to make it all work. The goal of this page is to provide enough information so that a beginner in hardware and software could build their own cube. \r\n\r\nIf you're interested in seeing more images before reading on, take a look at the [gallery](http://1drv.ms/1XGtxvg).\r\n\r\nReady to get started? Read on!\r\n\r\n***\r\n## Materials\r\n* 512 x 5mm diffused LEDs (Any color) \r\n* 4 x TLC59116 Constant current sink LED drivers \r\n* 1 x PIC18LF45K22 MCU\r\n* 8 x 2n4401 NPN type transistors\r\n* 8 x FQD11P06 P-Channel MOSFETs\r\n* 1 x LM350 voltage regulator\r\n* Breadboards to put it on\r\n\r\n***\r\n## High Level Design\r\n\r\n![Cube Schematic](https://bvtfsq-bn1305.files.1drv.com/y3m6SXNtfDGpxcCuLSCWiu8hR_I4eLB3B9x1GpAqS_q12BVjnfx0_Eifj3n6QOH6j0N9ueSNTJjgWB1yYSUjNJxoEjOnsKKaPv7G_-c3hylnCgbuiOhDJ8sBi0RppzKhmETSgaQ-krd7_TtyVTTcRfcvbRTdBcbGInjcUXmhMpJcNQ?width=1024&height=662&cropmode=none)\r\n*Schematic of the cube (Power lines not shown)*\r\n\r\nThe overall design is works be performing a raster scan from the top down on a 3D array of LEDs. The array is designed such that each of 8 8x8 layers are addressed one at a time. 4 constant current display drivers capable of addressing 16 LEDs each. A PIC MCU is used to coordinate the refresh cycles by writing to the drivers appropriately. Finally, a Raspberry Pi is used as an interface and frame rendering system that is capable of communicating frames to the PIC.\r\n\r\n### 512 LED Array\r\nThe whole array is broken into 8 layers of 64 LEDs Each. The cathodes of all the LEDs in a layer are soldered together allowing the whole layer to be powered at one time. The anodes of the LEDs form the columns of the array. Each layer then has 1 power input, and 64 addressable columns, allowing the driver to address 64 columns with the 4 display drivers.\r\n\r\n### Display Drivers\r\n4 Texas Instruments TLC59116 16-bit I2C LED Sink Drivers are used to address a layer of 8x8 (64) LEDs. These drivers can read in data for one layer of LEDs and latch the output so that the layer can be displayed.\r\n\r\n### Display controller\r\nThe display controller was a PIC18LF45K22 PIC Microcontroller programmed with a Mikro Electronika EasyProg. The driver was written in embedded C to act as a double buffered system capable of accepting asynchronous input through UART connection with a master controller while keeping the display refreshed.\r\n\r\n### Raspberry Pi\r\nTo give the cube the capability of almost anything, I used a Raspberry Pi as a master controller for the system. I run simple Raspian Linux on the Pi, and have developed a software API in Mono C# that abstracts away the underlying hardware interface and provides end users to easy address LEDs in a simple (x, y, z) format. The end result is a top level system that is capable of everything from simple animations to accepting network input and more!\r\n\r\n***\r\n## Construction\r\nConstructing the cube was done in parts. The hardest is the array itself.\r\n\r\n### LED Array\r\nThe array was built in layers of 8x8 LEDs. I found an old block of wood and used a drill press to place 5mm holes in a grid of 8x8, exactly 2cm (center to center) apart. I then placed the LEDs into the template and bent the cathodes down and soldered them together.\r\n\r\n![Block template](https://bfuiva-bn1305.files.1drv.com/y3m5IwR9HmbWNapaksOPUAZqUnFSD8sD88ZX-i4P109g_KOkuC0Q0_4Qtz76dakMoIDR8Gayy0wg69jBMbYc9OncF643oBKE3Qzd8aI7oBGpOG-7y1UhDaTgU1prEem-y4lXwLXuQLhIRWmr6VNGWqf4w?width=1024&height=579&cropmode=none)\r\n*Block template and LED layers being soldered together*\r\n\r\nEach layer was made first, then they were put together. I used Lego parts as scaffolding to hold the layers in place while I soldered them.\r\n\r\n![Finished Array](https://bfvt3w-bn1305.files.1drv.com/y3m3inepA4h2H0izW5T3mJEeWWbuRgA5gVzrLZG0U654f7t0FRHZgOiWkb26QYC8Sy77llMdn5sXuCmK0tgA12XI83gjiSEiLFWKX-BPCGOtzJo6dM_l1THb02m80rgBo6-CX2fxbXZkrOmrBFqWoXENA?width=807&height=1024&cropmode=none)\r\n*The finished array (Upside down, in the wood template)*\r\n\r\n### Display Drivers\r\nI paired off the drivers and soldered them onto small breadboards.\r\n\r\nComing soon: Board schematics for the drivers.\r\n\r\n### Layer Switches\r\nThe layer switches served as a way for the PIC's 3.3V logic to control a high current 12V line. Below is a diagram of the switches.\r\n\r\n![Layer switch diagram](https://bvtisq-bn1305.files.1drv.com/y3m2y_T8H6Q2uTNNXhNIzrf9KulXWN6ad0k53UnVj-M7YRBfa_vn2qOhEOik6aeoGAXnHqrJYCY6ctogLOnS1ZRpB83Oo2GhBvoaHdwcxbAjlrF1X-qoVagWLPyLjDiHlKkY2pNilS9uJ8eP1zPU5FIUsHxq-s25QBsMAhClIKa7co?width=623&height=1018&cropmode=none)\r\n\r\n*Circuit diagram of switches (Note: only 2 are depicted here, there are 8 total. Also, the lead cut off on the right connects to +12V, and the lead on the left connects to ground).*\r\n\r\nThe 8 input pins are connected to PORT B on the PIC. The PIC writes a single bit to the port to power on the layer.\r\n\r\n![Finished layer switches](https://bvtjsq-bn1305.files.1drv.com/y3mAE36_-l6kzFkRiEVbW220uX3xGIhNKFyCvnB7Da9enbof_rdIcpNSz4OoVZ2svpYtHXv-06m0R8T_0mjdzBIb-vCSv1x-RHg_4-CvGs2OPGFNLRB-7Kl3_4dpQkN9ZyC2eXOUljKx8XGCNvBRZ3bxA?width=967&height=1024&cropmode=none)\r\n*The finished layer switch circuit*\r\n\r\n### Power Supply\r\nThis section isn't finished yet!\r\n\r\n### Putting it together\r\nNeither is this one!\r\n\r\n***\r\n## Software\r\nThe software used to control the cube comes in to parts. The first is the embedded C code on the PIC. \r\n\r\n### Display Controller\r\nThe code on the PIC acts as a double buffered display driver, allowing outside sources to pipe in frames over UART. It manages the drivers, taking care of setting up the correct internal register values, and also includes a auto-idle animation (I.e. a screen saver) and software configurable internal registers for directing the operation of the display cycle.\r\n\r\nThe files related to the PIC code are in ledcube/LedCubeMCU/. It is a MikroElektronika C for PIC project and can only be compiled and loaded as is with the MikroE compiler and programmer.\r\n\r\n### Command/Response Protocol over UART\r\nIn the PIC code, in LedCubeMCUDriver.h, you will find the following lines,\r\n\r\n~~~C\r\n// Enum for commands\r\ntypedef enum {\r\n    NOOP,\r\n    READFRAME = 0x91,\r\n    SETCONTROL,\r\n    IDLE,\r\n    CLEAR = 0xEE,\r\n    ENDCMD = 0xFF\r\n} CUBECMD;\r\n~~~\r\n\r\nThese are arbitrarily defined, but my intent was that the usable commands would satisfy the following constraints:\r\n* Of the pairs of bits in a byte, at least one bit in the left position is set (I.e. 0b10101010 & CMD != 0x00). The reason is to not confuse commands with writing LED values, which are in the form of (0b01010101).\r\n* Should not be easy to mistakenly send over the line. Initially, when the Raspberry Pi boots, some garbage data can be sent over the UART accidentally (I.e. the line may drop to zero for an instant). This ensures that a READFRAME isn't started unless intended.\r\n\r\nThe PIC command system acts as a state machine. Here is a quick diagram:\r\n![Command FSM](https://qfqopa-bn1305.files.1drv.com/y3m8afrfNmjBMfrH6HJBqYE95Ds7YAtARSovfkdWq_JgZT-1BVLTQDOwdFBf5e6bokI0ivNYg8nCrkBt759VT2r809zmrlSmN2309RrQCgmHSClL9nA1f6gJe3Gd6Apv1zbhuiFySwEapLU-FfI_8wV7puF3omnmoRvacAWCKJDxkE?width=1805&height=1033&cropmode=none)\r\n*State machine for command processing*\r\n\r\nThe PIC will sit in IDLE until a byte is sent to it containing the command to start. If it is a READFRAME command, the PIC will enter the \"Read to Buffer\" state. This directs all further input to the back-buffer. Upon ENDCMD, the back-buffer will be swapped with the display buffer updating the frame instantly. For referance, a frame would be sent in the following format:\r\n\r\n~~~\r\nREADFRAME, <FRAME PAYLOAD>, ENDCMD\r\n~~~\r\n\r\nIf you wanted to send a frame setting all LEDs ON, it looks like:\r\n~~~\r\n9155...55FF\r\n~~~\r\nWhere 0x55 is repeated 128 times.\r\n\r\nUpon receiving any other command, the PIC will enter the \"Read Args\" state, which will read one byte at a time into an argument buffer until ENDCMD is received. A different buffer is used for this because the back-buffer is only for LED data and when swapped into the display, cannot contain any garbage from left over commands.\r\n\r\nThere is no error checking / correction done on the command system because throughput is important. As it stands, the interface is capable of about 66 FPS from the Pi to the display. Any sort of checking would only serve to add delay in reading a frame and reduce performance.\r\n\r\n### Raspberry Pi\r\nThe code for the Raspberry Pi is actually quite simple. Now that we have the PIC set up to manage the display, we can pipe frames to it over the Pi's UART asynchronously. In PyLedCube/LedCubePy, there is a Python module which serves as an interface. It simply opens the Pi's UART (/dev/ttyAMA0), and converts (x, y, z) coordinates into their corresponding bits in the buffer. When WriteBuffer() is called, it dumps the frame to the PIC to be displayed. \r\n\r\nSupport for modifying the PIC's internal variables through SETCONTROL is not supported yet. In the future, it will be possible to modify existing and future variables on the PIC through the Python interface.\r\n\r\nThere also is a C# based interface written to work with Mono on the Pi. In the future I plan to evaluate using Windows 10 IoT core on the Pi, which would require this interface. \r\n\r\n***\r\n## Authors and Contributors\r\nMichael Davies\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}